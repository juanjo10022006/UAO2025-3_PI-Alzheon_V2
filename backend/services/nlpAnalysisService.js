import axios from 'axios';

/**
 * Servicio para analizar transcripciones y textos usando Google Gemini API
 * Detecta patrones cognitivos, coherencia, claridad, y salud mental
 */

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_MODEL = 'gemini-2.5-flash'; // Modelo r√°pido y confiable

/**
 * Analizar texto usando Vertex AI para detectar patrones cognitivos
 * @param {string} texto - Texto o transcripci√≥n a analizar
 * @param {string} contexto - Contexto adicional (ej: "descripci√≥n de foto familiar")
 * @returns {Promise<Object>} - An√°lisis cognitivo
 */
export const analizarTexto = async (texto, contexto = '') => {
    console.log('üß† Iniciando an√°lisis cognitivo con Google Gemini...');
    console.log('   - Longitud del texto:', texto?.length || 0, 'caracteres');
    console.log('   - Contexto:', contexto);

    try {
        // Verificar si Gemini API est√° configurado
        if (!GEMINI_API_KEY) {
            console.warn('‚ö†Ô∏è GEMINI_API_KEY no configurada. Usando an√°lisis por defecto.');
            return generarAnalisisPorDefecto();
        }

        // Construir prompt especializado para an√°lisis cognitivo
        const prompt = construirPromptAnalisis(texto, contexto);

        // Llamar a Google Gemini API
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        
        const response = await axios.post(url, {
            contents: [{
                parts: [{
                    text: prompt
                }]
            }],
            generationConfig: {
                temperature: 0.3,
                maxOutputTokens: 4096, // Aumentado para evitar cortes
            }
        });

        console.log('‚úÖ An√°lisis completado por Google Gemini');

        // Parsear respuesta
        const responseData = response.data;
        console.log('üì¶ Respuesta completa de Gemini:', JSON.stringify(responseData, null, 2));
        
        const analisisTexto = response.data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
        
        // Debug: Mostrar la respuesta raw
        console.log('üìÑ Respuesta de Gemini:', analisisTexto.substring(0, 500));
        
        const analisis = parsearAnalisis(analisisTexto);

        console.log('üìä M√©tricas detectadas:');
        console.log('   - Coherencia:', analisis.coherencia);
        console.log('   - Claridad:', analisis.claridad);
        console.log('   - Riqueza l√©xica:', analisis.riquezaLexica);
        console.log('   - Memoria:', analisis.memoria);
        console.log('   - Puntuaci√≥n global:', analisis.puntuacionGlobal);

        return analisis;

    } catch (error) {
        console.error('‚ùå Error al analizar texto con Google Gemini:', error.message);
        if (error.response) {
            console.error('   Status:', error.response.status);
            console.error('   Respuesta:', JSON.stringify(error.response.data, null, 2));
        }
        // Retornar an√°lisis por defecto en caso de error
        return generarAnalisisPorDefecto();
    }
};

/**
 * Construir prompt especializado para an√°lisis cognitivo
 */
function construirPromptAnalisis(texto, contexto) {
    return `Analiza este texto de una persona mayor con posible deterioro cognitivo.

Texto: "${texto}"

Devuelve SOLO un JSON v√°lido con estas m√©tricas (valores 0.0-1.0):

{
  "coherencia": <0.0-1.0>,
  "claridad": <0.0-1.0>,
  "riquezaLexica": <0.0-1.0>,
  "memoria": <0.0-1.0>,
  "emocion": <0.0-1.0>,
  "orientacion": <0.0-1.0>,
  "razonamiento": <0.0-1.0>,
  "atencion": <0.0-1.0>,
  "palabrasUnicas": <n√∫mero>,
  "palabrasTotales": <n√∫mero>,
  "longitudPromedioPalabras": <n√∫mero>,
  "pausas": <n√∫mero>,
  "repeticiones": <n√∫mero>,
  "observaciones": "breve observaci√≥n cl√≠nica",
  "alertas": ["se√±ales de alerta si existen"]
}

Responde SOLO con el JSON.`;
}

/**
 * Parsear respuesta de Vertex AI
 */
function parsearAnalisis(textoAnalisis) {
    try {
        // Limpiar el texto para extraer solo el JSON
        // Buscar el JSON entre ```json y ``` o directamente { ... }
        let jsonText = textoAnalisis;
        
        // Intentar extraer de bloques de c√≥digo markdown
        const codeBlockMatch = textoAnalisis.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (codeBlockMatch) {
            jsonText = codeBlockMatch[1];
        } else {
            // Buscar directamente el objeto JSON
            const jsonMatch = textoAnalisis.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                jsonText = jsonMatch[0];
            }
        }
        
        console.log('üîç JSON extra√≠do:', jsonText.substring(0, 300));
        
        const analisis = JSON.parse(jsonText);
        
        // Validar y normalizar valores
        const metricas = {
            coherencia: Math.min(Math.max(analisis.coherencia || 0.5, 0), 1),
            claridad: Math.min(Math.max(analisis.claridad || 0.5, 0), 1),
            riquezaLexica: Math.min(Math.max(analisis.riquezaLexica || 0.5, 0), 1),
            memoria: Math.min(Math.max(analisis.memoria || 0.5, 0), 1),
            emocion: Math.min(Math.max(analisis.emocion || 0.5, 0), 1),
            orientacion: Math.min(Math.max(analisis.orientacion || 0.5, 0), 1),
            razonamiento: Math.min(Math.max(analisis.razonamiento || 0.5, 0), 1),
            atencion: Math.min(Math.max(analisis.atencion || 0.5, 0), 1),
            palabrasUnicas: analisis.palabrasUnicas || 0,
            palabrasTotales: analisis.palabrasTotales || 0,
            longitudPromedioPalabras: analisis.longitudPromedioPalabras || 0,
            pausas: analisis.pausas || 0,
            repeticiones: analisis.repeticiones || 0,
            observaciones: analisis.observaciones || '',
            alertas: Array.isArray(analisis.alertas) ? analisis.alertas : [],
            fechaAnalisis: new Date()
        };

        // Calcular puntuaci√≥n global
        metricas.puntuacionGlobal = calcularPuntuacionGlobal(metricas);

        return metricas;
    } catch (error) {
        console.error('‚ùå Error al parsear an√°lisis:', error.message);
    }
    
    return generarAnalisisPorDefecto();
}

/**
 * Generar an√°lisis por defecto cuando no hay API key o hay error
 */
function generarAnalisisPorDefecto() {
    const metricas = {
        coherencia: 0.7,
        claridad: 0.7,
        riquezaLexica: 0.6,
        memoria: 0.7,
        emocion: 0.6,
        orientacion: 0.7,
        razonamiento: 0.7,
        atencion: 0.7,
        palabrasUnicas: 0,
        palabrasTotales: 0,
        longitudPromedioPalabras: 0,
        pausas: 0,
        repeticiones: 0,
        observaciones: 'An√°lisis no disponible - configurar Vertex AI',
        alertas: [],
        fechaAnalisis: new Date()
    };

    // Calcular puntuaci√≥n global
    metricas.puntuacionGlobal = calcularPuntuacionGlobal(metricas);

    return metricas;
}

/**
 * Calcular puntuaci√≥n cognitiva global (0-100)
 */
export const calcularPuntuacionGlobal = (analisis) => {
    const pesos = {
        coherencia: 0.20,
        claridad: 0.15,
        riquezaLexica: 0.10,
        memoria: 0.20,
        emocion: 0.05,
        orientacion: 0.15,
        razonamiento: 0.10,
        atencion: 0.05
    };

    let puntuacion = 0;
    for (const [metrica, peso] of Object.entries(pesos)) {
        puntuacion += (analisis[metrica] || 0) * peso;
    }

    return Math.round(puntuacion * 100);
};

/**
 * Detectar desviaciones significativas respecto a l√≠nea base
 */
export const detectarDesviaciones = (analisisActual, lineaBase, umbral = 0.15) => {
    const desviaciones = [];

    const metricas = ['coherencia', 'claridad', 'memoria', 'orientacion', 'razonamiento'];

    for (const metrica of metricas) {
        const valorActual = analisisActual[metrica] || 0;
        const valorBase = lineaBase[metrica] || 0;
        const diferencia = valorBase - valorActual;

        // Detectar solo deterioros significativos
        if (diferencia > umbral) {
            const porcentaje = Math.round((diferencia / valorBase) * 100);
            desviaciones.push({
                metrica,
                valorAnterior: valorBase,
                valorActual,
                diferencia,
                porcentaje,
                severidad: diferencia > 0.3 ? 'alta' : diferencia > 0.2 ? 'media' : 'baja'
            });
        }
    }

    return desviaciones;
};

/**
 * Generar recomendaciones basadas en el an√°lisis
 */
export const generarRecomendaciones = (desviaciones) => {
    const recomendaciones = [];

    for (const desv of desviaciones) {
        switch (desv.metrica) {
            case 'coherencia':
                recomendaciones.push({
                    tipo: 'atencion',
                    mensaje: 'Se detect√≥ disminuci√≥n en la coherencia del discurso. Considerar evaluaci√≥n adicional.',
                    prioridad: desv.severidad
                });
                break;
            case 'memoria':
                recomendaciones.push({
                    tipo: 'memoria',
                    mensaje: 'Posible deterioro en la memoria. Recomendar ejercicios de estimulaci√≥n cognitiva.',
                    prioridad: desv.severidad
                });
                break;
            case 'orientacion':
                recomendaciones.push({
                    tipo: 'orientacion',
                    mensaje: 'Dificultades en la orientaci√≥n. Evaluar capacidad para actividades diarias.',
                    prioridad: desv.severidad
                });
                break;
            case 'claridad':
                recomendaciones.push({
                    tipo: 'comunicacion',
                    mensaje: 'Disminuci√≥n en la claridad de expresi√≥n. Monitorear evoluci√≥n.',
                    prioridad: desv.severidad
                });
                break;
            case 'razonamiento':
                recomendaciones.push({
                    tipo: 'razonamiento',
                    mensaje: 'Cambios en la capacidad de razonamiento. Considerar ajuste en el plan de cuidados.',
                    prioridad: desv.severidad
                });
                break;
        }
    }

    return recomendaciones;
};
